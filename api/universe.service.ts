/**
 * EVE Swagger Interface
 * An OpenAPI for EVE Online
 *
 * OpenAPI spec version: 0.8.6
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { BadRequest } from '../model/badRequest';
import { ErrorLimited } from '../model/errorLimited';
import { Forbidden } from '../model/forbidden';
import { GatewayTimeout } from '../model/gatewayTimeout';
import { GetUniverseAsteroidBeltsAsteroidBeltIdNotFound } from '../model/getUniverseAsteroidBeltsAsteroidBeltIdNotFound';
import { GetUniverseAsteroidBeltsAsteroidBeltIdOk } from '../model/getUniverseAsteroidBeltsAsteroidBeltIdOk';
import { GetUniverseCategoriesCategoryIdNotFound } from '../model/getUniverseCategoriesCategoryIdNotFound';
import { GetUniverseCategoriesCategoryIdOk } from '../model/getUniverseCategoriesCategoryIdOk';
import { GetUniverseConstellationsConstellationIdNotFound } from '../model/getUniverseConstellationsConstellationIdNotFound';
import { GetUniverseConstellationsConstellationIdOk } from '../model/getUniverseConstellationsConstellationIdOk';
import { GetUniverseGraphicsGraphicIdNotFound } from '../model/getUniverseGraphicsGraphicIdNotFound';
import { GetUniverseGraphicsGraphicIdOk } from '../model/getUniverseGraphicsGraphicIdOk';
import { GetUniverseGroupsGroupIdNotFound } from '../model/getUniverseGroupsGroupIdNotFound';
import { GetUniverseGroupsGroupIdOk } from '../model/getUniverseGroupsGroupIdOk';
import { GetUniverseMoonsMoonIdNotFound } from '../model/getUniverseMoonsMoonIdNotFound';
import { GetUniverseMoonsMoonIdOk } from '../model/getUniverseMoonsMoonIdOk';
import { GetUniversePlanetsPlanetIdNotFound } from '../model/getUniversePlanetsPlanetIdNotFound';
import { GetUniversePlanetsPlanetIdOk } from '../model/getUniversePlanetsPlanetIdOk';
import { GetUniverseRegionsRegionIdNotFound } from '../model/getUniverseRegionsRegionIdNotFound';
import { GetUniverseRegionsRegionIdOk } from '../model/getUniverseRegionsRegionIdOk';
import { GetUniverseStargatesStargateIdNotFound } from '../model/getUniverseStargatesStargateIdNotFound';
import { GetUniverseStargatesStargateIdOk } from '../model/getUniverseStargatesStargateIdOk';
import { GetUniverseStarsStarIdOk } from '../model/getUniverseStarsStarIdOk';
import { GetUniverseStationsStationIdNotFound } from '../model/getUniverseStationsStationIdNotFound';
import { GetUniverseStationsStationIdOk } from '../model/getUniverseStationsStationIdOk';
import { GetUniverseStructuresStructureIdNotFound } from '../model/getUniverseStructuresStructureIdNotFound';
import { GetUniverseStructuresStructureIdOk } from '../model/getUniverseStructuresStructureIdOk';
import { GetUniverseSystemsSystemIdNotFound } from '../model/getUniverseSystemsSystemIdNotFound';
import { GetUniverseSystemsSystemIdOk } from '../model/getUniverseSystemsSystemIdOk';
import { GetUniverseTypesTypeIdNotFound } from '../model/getUniverseTypesTypeIdNotFound';
import { GetUniverseTypesTypeIdOk } from '../model/getUniverseTypesTypeIdOk';
import { InternalServerError } from '../model/internalServerError';
import { PostUniverseIdsOk } from '../model/postUniverseIdsOk';
import { PostUniverseNamesNotFound } from '../model/postUniverseNamesNotFound';
import { ServiceUnavailable } from '../model/serviceUnavailable';
import { Unauthorized } from '../model/unauthorized';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class UniverseService {

    protected basePath = 'https://esi.evetech.net/latest';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Get ancestries
     * Get all character ancestries  --- Alternate route: &#x60;/dev/universe/ancestries/&#x60;  Alternate route: &#x60;/legacy/universe/ancestries/&#x60;  Alternate route: &#x60;/v1/universe/ancestries/&#x60;  --- This route expires daily at 11:05
     * @param Accept_Language Language to use in the response
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseAncestries(Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'body', reportProgress?: boolean): Observable<Array<any>>;
    public getUniverseAncestries(Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<any>>>;
    public getUniverseAncestries(Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<any>>>;
    public getUniverseAncestries(Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }

        let headers = this.defaultHeaders;
        if (Accept_Language !== undefined && Accept_Language !== null) {
            headers = headers.set('Accept-Language', String(Accept_Language));
        }
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<any>>(`${this.basePath}/universe/ancestries/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get asteroid belt information
     * Get information on an asteroid belt  --- Alternate route: &#x60;/dev/universe/asteroid_belts/{asteroid_belt_id}/&#x60;  Alternate route: &#x60;/legacy/universe/asteroid_belts/{asteroid_belt_id}/&#x60;  Alternate route: &#x60;/v1/universe/asteroid_belts/{asteroid_belt_id}/&#x60;  --- This route expires daily at 11:05
     * @param asteroid_belt_id asteroid_belt_id integer
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseAsteroidBeltsAsteroidBeltId(asteroid_belt_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'body', reportProgress?: boolean): Observable<GetUniverseAsteroidBeltsAsteroidBeltIdOk>;
    public getUniverseAsteroidBeltsAsteroidBeltId(asteroid_belt_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniverseAsteroidBeltsAsteroidBeltIdOk>>;
    public getUniverseAsteroidBeltsAsteroidBeltId(asteroid_belt_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniverseAsteroidBeltsAsteroidBeltIdOk>>;
    public getUniverseAsteroidBeltsAsteroidBeltId(asteroid_belt_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (asteroid_belt_id === null || asteroid_belt_id === undefined) {
            throw new Error('Required parameter asteroid_belt_id was null or undefined when calling getUniverseAsteroidBeltsAsteroidBeltId.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniverseAsteroidBeltsAsteroidBeltIdOk>(`${this.basePath}/universe/asteroid_belts/${encodeURIComponent(String(asteroid_belt_id))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get bloodlines
     * Get a list of bloodlines  --- Alternate route: &#x60;/dev/universe/bloodlines/&#x60;  Alternate route: &#x60;/legacy/universe/bloodlines/&#x60;  Alternate route: &#x60;/v1/universe/bloodlines/&#x60;  --- This route expires daily at 11:05
     * @param Accept_Language Language to use in the response
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseBloodlines(Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'body', reportProgress?: boolean): Observable<Array<any>>;
    public getUniverseBloodlines(Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<any>>>;
    public getUniverseBloodlines(Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<any>>>;
    public getUniverseBloodlines(Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }

        let headers = this.defaultHeaders;
        if (Accept_Language !== undefined && Accept_Language !== null) {
            headers = headers.set('Accept-Language', String(Accept_Language));
        }
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<any>>(`${this.basePath}/universe/bloodlines/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get item categories
     * Get a list of item categories  --- Alternate route: &#x60;/dev/universe/categories/&#x60;  Alternate route: &#x60;/legacy/universe/categories/&#x60;  Alternate route: &#x60;/v1/universe/categories/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseCategories(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<number>>;
    public getUniverseCategories(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<number>>>;
    public getUniverseCategories(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<number>>>;
    public getUniverseCategories(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<number>>(`${this.basePath}/universe/categories/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get item category information
     * Get information of an item category  --- Alternate route: &#x60;/dev/universe/categories/{category_id}/&#x60;  Alternate route: &#x60;/legacy/universe/categories/{category_id}/&#x60;  Alternate route: &#x60;/v1/universe/categories/{category_id}/&#x60;  --- This route expires daily at 11:05
     * @param category_id An Eve item category ID
     * @param Accept_Language Language to use in the response
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseCategoriesCategoryId(category_id: number, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'body', reportProgress?: boolean): Observable<GetUniverseCategoriesCategoryIdOk>;
    public getUniverseCategoriesCategoryId(category_id: number, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniverseCategoriesCategoryIdOk>>;
    public getUniverseCategoriesCategoryId(category_id: number, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniverseCategoriesCategoryIdOk>>;
    public getUniverseCategoriesCategoryId(category_id: number, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (category_id === null || category_id === undefined) {
            throw new Error('Required parameter category_id was null or undefined when calling getUniverseCategoriesCategoryId.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }

        let headers = this.defaultHeaders;
        if (Accept_Language !== undefined && Accept_Language !== null) {
            headers = headers.set('Accept-Language', String(Accept_Language));
        }
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniverseCategoriesCategoryIdOk>(`${this.basePath}/universe/categories/${encodeURIComponent(String(category_id))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get constellations
     * Get a list of constellations  --- Alternate route: &#x60;/dev/universe/constellations/&#x60;  Alternate route: &#x60;/legacy/universe/constellations/&#x60;  Alternate route: &#x60;/v1/universe/constellations/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseConstellations(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<number>>;
    public getUniverseConstellations(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<number>>>;
    public getUniverseConstellations(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<number>>>;
    public getUniverseConstellations(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<number>>(`${this.basePath}/universe/constellations/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get constellation information
     * Get information on a constellation  --- Alternate route: &#x60;/dev/universe/constellations/{constellation_id}/&#x60;  Alternate route: &#x60;/legacy/universe/constellations/{constellation_id}/&#x60;  Alternate route: &#x60;/v1/universe/constellations/{constellation_id}/&#x60;  --- This route expires daily at 11:05
     * @param constellation_id constellation_id integer
     * @param Accept_Language Language to use in the response
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseConstellationsConstellationId(constellation_id: number, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'body', reportProgress?: boolean): Observable<GetUniverseConstellationsConstellationIdOk>;
    public getUniverseConstellationsConstellationId(constellation_id: number, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniverseConstellationsConstellationIdOk>>;
    public getUniverseConstellationsConstellationId(constellation_id: number, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniverseConstellationsConstellationIdOk>>;
    public getUniverseConstellationsConstellationId(constellation_id: number, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (constellation_id === null || constellation_id === undefined) {
            throw new Error('Required parameter constellation_id was null or undefined when calling getUniverseConstellationsConstellationId.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }

        let headers = this.defaultHeaders;
        if (Accept_Language !== undefined && Accept_Language !== null) {
            headers = headers.set('Accept-Language', String(Accept_Language));
        }
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniverseConstellationsConstellationIdOk>(`${this.basePath}/universe/constellations/${encodeURIComponent(String(constellation_id))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get factions
     * Get a list of factions  --- Alternate route: &#x60;/dev/universe/factions/&#x60;  Alternate route: &#x60;/v2/universe/factions/&#x60;  --- This route expires daily at 11:05
     * @param Accept_Language Language to use in the response
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseFactions(Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'body', reportProgress?: boolean): Observable<Array<any>>;
    public getUniverseFactions(Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<any>>>;
    public getUniverseFactions(Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<any>>>;
    public getUniverseFactions(Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }

        let headers = this.defaultHeaders;
        if (Accept_Language !== undefined && Accept_Language !== null) {
            headers = headers.set('Accept-Language', String(Accept_Language));
        }
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<any>>(`${this.basePath}/universe/factions/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get graphics
     * Get a list of graphics  --- Alternate route: &#x60;/dev/universe/graphics/&#x60;  Alternate route: &#x60;/legacy/universe/graphics/&#x60;  Alternate route: &#x60;/v1/universe/graphics/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseGraphics(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<number>>;
    public getUniverseGraphics(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<number>>>;
    public getUniverseGraphics(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<number>>>;
    public getUniverseGraphics(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<number>>(`${this.basePath}/universe/graphics/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get graphic information
     * Get information on a graphic  --- Alternate route: &#x60;/dev/universe/graphics/{graphic_id}/&#x60;  Alternate route: &#x60;/legacy/universe/graphics/{graphic_id}/&#x60;  Alternate route: &#x60;/v1/universe/graphics/{graphic_id}/&#x60;  --- This route expires daily at 11:05
     * @param graphic_id graphic_id integer
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseGraphicsGraphicId(graphic_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'body', reportProgress?: boolean): Observable<GetUniverseGraphicsGraphicIdOk>;
    public getUniverseGraphicsGraphicId(graphic_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniverseGraphicsGraphicIdOk>>;
    public getUniverseGraphicsGraphicId(graphic_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniverseGraphicsGraphicIdOk>>;
    public getUniverseGraphicsGraphicId(graphic_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (graphic_id === null || graphic_id === undefined) {
            throw new Error('Required parameter graphic_id was null or undefined when calling getUniverseGraphicsGraphicId.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniverseGraphicsGraphicIdOk>(`${this.basePath}/universe/graphics/${encodeURIComponent(String(graphic_id))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get item groups
     * Get a list of item groups  --- Alternate route: &#x60;/dev/universe/groups/&#x60;  Alternate route: &#x60;/legacy/universe/groups/&#x60;  Alternate route: &#x60;/v1/universe/groups/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseGroups(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, page?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<number>>;
    public getUniverseGroups(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, page?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<number>>>;
    public getUniverseGroups(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, page?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<number>>>;
    public getUniverseGroups(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, page?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }

        let headers = this.defaultHeaders;
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<number>>(`${this.basePath}/universe/groups/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get item group information
     * Get information on an item group  --- Alternate route: &#x60;/dev/universe/groups/{group_id}/&#x60;  Alternate route: &#x60;/legacy/universe/groups/{group_id}/&#x60;  Alternate route: &#x60;/v1/universe/groups/{group_id}/&#x60;  --- This route expires daily at 11:05
     * @param group_id An Eve item group ID
     * @param Accept_Language Language to use in the response
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseGroupsGroupId(group_id: number, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'body', reportProgress?: boolean): Observable<GetUniverseGroupsGroupIdOk>;
    public getUniverseGroupsGroupId(group_id: number, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniverseGroupsGroupIdOk>>;
    public getUniverseGroupsGroupId(group_id: number, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniverseGroupsGroupIdOk>>;
    public getUniverseGroupsGroupId(group_id: number, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (group_id === null || group_id === undefined) {
            throw new Error('Required parameter group_id was null or undefined when calling getUniverseGroupsGroupId.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }

        let headers = this.defaultHeaders;
        if (Accept_Language !== undefined && Accept_Language !== null) {
            headers = headers.set('Accept-Language', String(Accept_Language));
        }
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniverseGroupsGroupIdOk>(`${this.basePath}/universe/groups/${encodeURIComponent(String(group_id))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get moon information
     * Get information on a moon  --- Alternate route: &#x60;/dev/universe/moons/{moon_id}/&#x60;  Alternate route: &#x60;/legacy/universe/moons/{moon_id}/&#x60;  Alternate route: &#x60;/v1/universe/moons/{moon_id}/&#x60;  --- This route expires daily at 11:05
     * @param moon_id moon_id integer
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseMoonsMoonId(moon_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'body', reportProgress?: boolean): Observable<GetUniverseMoonsMoonIdOk>;
    public getUniverseMoonsMoonId(moon_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniverseMoonsMoonIdOk>>;
    public getUniverseMoonsMoonId(moon_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniverseMoonsMoonIdOk>>;
    public getUniverseMoonsMoonId(moon_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (moon_id === null || moon_id === undefined) {
            throw new Error('Required parameter moon_id was null or undefined when calling getUniverseMoonsMoonId.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniverseMoonsMoonIdOk>(`${this.basePath}/universe/moons/${encodeURIComponent(String(moon_id))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get planet information
     * Get information on a planet  --- Alternate route: &#x60;/dev/universe/planets/{planet_id}/&#x60;  Alternate route: &#x60;/legacy/universe/planets/{planet_id}/&#x60;  Alternate route: &#x60;/v1/universe/planets/{planet_id}/&#x60;  --- This route expires daily at 11:05
     * @param planet_id planet_id integer
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniversePlanetsPlanetId(planet_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'body', reportProgress?: boolean): Observable<GetUniversePlanetsPlanetIdOk>;
    public getUniversePlanetsPlanetId(planet_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniversePlanetsPlanetIdOk>>;
    public getUniversePlanetsPlanetId(planet_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniversePlanetsPlanetIdOk>>;
    public getUniversePlanetsPlanetId(planet_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (planet_id === null || planet_id === undefined) {
            throw new Error('Required parameter planet_id was null or undefined when calling getUniversePlanetsPlanetId.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniversePlanetsPlanetIdOk>(`${this.basePath}/universe/planets/${encodeURIComponent(String(planet_id))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get character races
     * Get a list of character races  --- Alternate route: &#x60;/dev/universe/races/&#x60;  Alternate route: &#x60;/legacy/universe/races/&#x60;  Alternate route: &#x60;/v1/universe/races/&#x60;  --- This route expires daily at 11:05
     * @param Accept_Language Language to use in the response
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseRaces(Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'body', reportProgress?: boolean): Observable<Array<any>>;
    public getUniverseRaces(Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<any>>>;
    public getUniverseRaces(Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<any>>>;
    public getUniverseRaces(Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }

        let headers = this.defaultHeaders;
        if (Accept_Language !== undefined && Accept_Language !== null) {
            headers = headers.set('Accept-Language', String(Accept_Language));
        }
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<any>>(`${this.basePath}/universe/races/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get regions
     * Get a list of regions  --- Alternate route: &#x60;/dev/universe/regions/&#x60;  Alternate route: &#x60;/legacy/universe/regions/&#x60;  Alternate route: &#x60;/v1/universe/regions/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseRegions(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<number>>;
    public getUniverseRegions(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<number>>>;
    public getUniverseRegions(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<number>>>;
    public getUniverseRegions(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<number>>(`${this.basePath}/universe/regions/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get region information
     * Get information on a region  --- Alternate route: &#x60;/dev/universe/regions/{region_id}/&#x60;  Alternate route: &#x60;/legacy/universe/regions/{region_id}/&#x60;  Alternate route: &#x60;/v1/universe/regions/{region_id}/&#x60;  --- This route expires daily at 11:05
     * @param region_id region_id integer
     * @param Accept_Language Language to use in the response
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseRegionsRegionId(region_id: number, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'body', reportProgress?: boolean): Observable<GetUniverseRegionsRegionIdOk>;
    public getUniverseRegionsRegionId(region_id: number, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniverseRegionsRegionIdOk>>;
    public getUniverseRegionsRegionId(region_id: number, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniverseRegionsRegionIdOk>>;
    public getUniverseRegionsRegionId(region_id: number, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (region_id === null || region_id === undefined) {
            throw new Error('Required parameter region_id was null or undefined when calling getUniverseRegionsRegionId.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }

        let headers = this.defaultHeaders;
        if (Accept_Language !== undefined && Accept_Language !== null) {
            headers = headers.set('Accept-Language', String(Accept_Language));
        }
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniverseRegionsRegionIdOk>(`${this.basePath}/universe/regions/${encodeURIComponent(String(region_id))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get stargate information
     * Get information on a stargate  --- Alternate route: &#x60;/dev/universe/stargates/{stargate_id}/&#x60;  Alternate route: &#x60;/legacy/universe/stargates/{stargate_id}/&#x60;  Alternate route: &#x60;/v1/universe/stargates/{stargate_id}/&#x60;  --- This route expires daily at 11:05
     * @param stargate_id stargate_id integer
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseStargatesStargateId(stargate_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'body', reportProgress?: boolean): Observable<GetUniverseStargatesStargateIdOk>;
    public getUniverseStargatesStargateId(stargate_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniverseStargatesStargateIdOk>>;
    public getUniverseStargatesStargateId(stargate_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniverseStargatesStargateIdOk>>;
    public getUniverseStargatesStargateId(stargate_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (stargate_id === null || stargate_id === undefined) {
            throw new Error('Required parameter stargate_id was null or undefined when calling getUniverseStargatesStargateId.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniverseStargatesStargateIdOk>(`${this.basePath}/universe/stargates/${encodeURIComponent(String(stargate_id))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get star information
     * Get information on a star  --- Alternate route: &#x60;/dev/universe/stars/{star_id}/&#x60;  Alternate route: &#x60;/legacy/universe/stars/{star_id}/&#x60;  Alternate route: &#x60;/v1/universe/stars/{star_id}/&#x60;  --- This route expires daily at 11:05
     * @param star_id star_id integer
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseStarsStarId(star_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'body', reportProgress?: boolean): Observable<GetUniverseStarsStarIdOk>;
    public getUniverseStarsStarId(star_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniverseStarsStarIdOk>>;
    public getUniverseStarsStarId(star_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniverseStarsStarIdOk>>;
    public getUniverseStarsStarId(star_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (star_id === null || star_id === undefined) {
            throw new Error('Required parameter star_id was null or undefined when calling getUniverseStarsStarId.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniverseStarsStarIdOk>(`${this.basePath}/universe/stars/${encodeURIComponent(String(star_id))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get station information
     * Get information on a station  --- Alternate route: &#x60;/dev/universe/stations/{station_id}/&#x60;  Alternate route: &#x60;/v2/universe/stations/{station_id}/&#x60;  --- This route expires daily at 11:05
     * @param station_id station_id integer
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseStationsStationId(station_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'body', reportProgress?: boolean): Observable<GetUniverseStationsStationIdOk>;
    public getUniverseStationsStationId(station_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniverseStationsStationIdOk>>;
    public getUniverseStationsStationId(station_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniverseStationsStationIdOk>>;
    public getUniverseStationsStationId(station_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (station_id === null || station_id === undefined) {
            throw new Error('Required parameter station_id was null or undefined when calling getUniverseStationsStationId.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniverseStationsStationIdOk>(`${this.basePath}/universe/stations/${encodeURIComponent(String(station_id))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List all public structures
     * List all public structures  --- Alternate route: &#x60;/dev/universe/structures/&#x60;  Alternate route: &#x60;/legacy/universe/structures/&#x60;  Alternate route: &#x60;/v1/universe/structures/&#x60;  --- This route is cached for up to 3600 seconds
     * @param datasource The server name you would like data from
     * @param filter Only list public structures that have this service online
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseStructures(datasource?: 'tranquility' | 'singularity', filter?: 'market' | 'manufacturing_basic', If_None_Match?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<number>>;
    public getUniverseStructures(datasource?: 'tranquility' | 'singularity', filter?: 'market' | 'manufacturing_basic', If_None_Match?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<number>>>;
    public getUniverseStructures(datasource?: 'tranquility' | 'singularity', filter?: 'market' | 'manufacturing_basic', If_None_Match?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<number>>>;
    public getUniverseStructures(datasource?: 'tranquility' | 'singularity', filter?: 'market' | 'manufacturing_basic', If_None_Match?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (filter !== undefined && filter !== null) {
            queryParameters = queryParameters.set('filter', <any>filter);
        }

        let headers = this.defaultHeaders;
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<number>>(`${this.basePath}/universe/structures/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get structure information
     * Returns information on requested structure if you are on the ACL. Otherwise, returns \&quot;Forbidden\&quot; for all inputs.  --- Alternate route: &#x60;/dev/universe/structures/{structure_id}/&#x60;  Alternate route: &#x60;/v2/universe/structures/{structure_id}/&#x60;  --- This route is cached for up to 3600 seconds
     * @param structure_id An Eve structure ID
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param token Access token to use if unable to set a header
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseStructuresStructureId(structure_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, token?: string, observe?: 'body', reportProgress?: boolean): Observable<GetUniverseStructuresStructureIdOk>;
    public getUniverseStructuresStructureId(structure_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, token?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniverseStructuresStructureIdOk>>;
    public getUniverseStructuresStructureId(structure_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, token?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniverseStructuresStructureIdOk>>;
    public getUniverseStructuresStructureId(structure_id: number, datasource?: 'tranquility' | 'singularity', If_None_Match?: string, token?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (structure_id === null || structure_id === undefined) {
            throw new Error('Required parameter structure_id was null or undefined when calling getUniverseStructuresStructureId.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (token !== undefined && token !== null) {
            queryParameters = queryParameters.set('token', <any>token);
        }

        let headers = this.defaultHeaders;
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // authentication (evesso) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniverseStructuresStructureIdOk>(`${this.basePath}/universe/structures/${encodeURIComponent(String(structure_id))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get system jumps
     * Get the number of jumps in solar systems within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with jumps will be listed  --- Alternate route: &#x60;/dev/universe/system_jumps/&#x60;  Alternate route: &#x60;/legacy/universe/system_jumps/&#x60;  Alternate route: &#x60;/v1/universe/system_jumps/&#x60;  --- This route is cached for up to 3600 seconds
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseSystemJumps(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<any>>;
    public getUniverseSystemJumps(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<any>>>;
    public getUniverseSystemJumps(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<any>>>;
    public getUniverseSystemJumps(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<any>>(`${this.basePath}/universe/system_jumps/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get system kills
     * Get the number of ship, pod and NPC kills per solar system within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with kills will be listed  --- Alternate route: &#x60;/dev/universe/system_kills/&#x60;  Alternate route: &#x60;/v2/universe/system_kills/&#x60;  --- This route is cached for up to 3600 seconds
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseSystemKills(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<any>>;
    public getUniverseSystemKills(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<any>>>;
    public getUniverseSystemKills(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<any>>>;
    public getUniverseSystemKills(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<any>>(`${this.basePath}/universe/system_kills/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get solar systems
     * Get a list of solar systems  --- Alternate route: &#x60;/dev/universe/systems/&#x60;  Alternate route: &#x60;/legacy/universe/systems/&#x60;  Alternate route: &#x60;/v1/universe/systems/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseSystems(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<number>>;
    public getUniverseSystems(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<number>>>;
    public getUniverseSystems(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<number>>>;
    public getUniverseSystems(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<number>>(`${this.basePath}/universe/systems/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get solar system information
     * Get information on a solar system.  --- Alternate route: &#x60;/dev/universe/systems/{system_id}/&#x60;  Alternate route: &#x60;/v4/universe/systems/{system_id}/&#x60;  --- This route expires daily at 11:05
     * @param system_id system_id integer
     * @param Accept_Language Language to use in the response
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseSystemsSystemId(system_id: number, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'body', reportProgress?: boolean): Observable<GetUniverseSystemsSystemIdOk>;
    public getUniverseSystemsSystemId(system_id: number, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniverseSystemsSystemIdOk>>;
    public getUniverseSystemsSystemId(system_id: number, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniverseSystemsSystemIdOk>>;
    public getUniverseSystemsSystemId(system_id: number, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (system_id === null || system_id === undefined) {
            throw new Error('Required parameter system_id was null or undefined when calling getUniverseSystemsSystemId.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }

        let headers = this.defaultHeaders;
        if (Accept_Language !== undefined && Accept_Language !== null) {
            headers = headers.set('Accept-Language', String(Accept_Language));
        }
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniverseSystemsSystemIdOk>(`${this.basePath}/universe/systems/${encodeURIComponent(String(system_id))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get types
     * Get a list of type ids  --- Alternate route: &#x60;/dev/universe/types/&#x60;  Alternate route: &#x60;/legacy/universe/types/&#x60;  Alternate route: &#x60;/v1/universe/types/&#x60;  --- This route expires daily at 11:05
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param page Which page of results to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseTypes(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, page?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<number>>;
    public getUniverseTypes(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, page?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<number>>>;
    public getUniverseTypes(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, page?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<number>>>;
    public getUniverseTypes(datasource?: 'tranquility' | 'singularity', If_None_Match?: string, page?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }

        let headers = this.defaultHeaders;
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<number>>(`${this.basePath}/universe/types/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get type information
     * Get information on a type  --- Alternate route: &#x60;/dev/universe/types/{type_id}/&#x60;  Alternate route: &#x60;/v3/universe/types/{type_id}/&#x60;  --- This route expires daily at 11:05
     * @param type_id An Eve item type ID
     * @param Accept_Language Language to use in the response
     * @param datasource The server name you would like data from
     * @param If_None_Match ETag from a previous request. A 304 will be returned if this matches the current ETag
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUniverseTypesTypeId(type_id: number, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'body', reportProgress?: boolean): Observable<GetUniverseTypesTypeIdOk>;
    public getUniverseTypesTypeId(type_id: number, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUniverseTypesTypeIdOk>>;
    public getUniverseTypesTypeId(type_id: number, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUniverseTypesTypeIdOk>>;
    public getUniverseTypesTypeId(type_id: number, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', If_None_Match?: string, language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (type_id === null || type_id === undefined) {
            throw new Error('Required parameter type_id was null or undefined when calling getUniverseTypesTypeId.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }

        let headers = this.defaultHeaders;
        if (Accept_Language !== undefined && Accept_Language !== null) {
            headers = headers.set('Accept-Language', String(Accept_Language));
        }
        if (If_None_Match !== undefined && If_None_Match !== null) {
            headers = headers.set('If-None-Match', String(If_None_Match));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetUniverseTypesTypeIdOk>(`${this.basePath}/universe/types/${encodeURIComponent(String(type_id))}/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Bulk names to IDs
     * Resolve a set of names to IDs in the following categories: agents, alliances, characters, constellations, corporations factions, inventory_types, regions, stations, and systems. Only exact matches will be returned. All names searched for are cached for 12 hours  --- Alternate route: &#x60;/dev/universe/ids/&#x60;  Alternate route: &#x60;/legacy/universe/ids/&#x60;  Alternate route: &#x60;/v1/universe/ids/&#x60; 
     * @param names The names to resolve
     * @param Accept_Language Language to use in the response
     * @param datasource The server name you would like data from
     * @param language Language to use in the response, takes precedence over Accept-Language
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postUniverseIds(names: Array<string>, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'body', reportProgress?: boolean): Observable<PostUniverseIdsOk>;
    public postUniverseIds(names: Array<string>, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PostUniverseIdsOk>>;
    public postUniverseIds(names: Array<string>, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PostUniverseIdsOk>>;
    public postUniverseIds(names: Array<string>, Accept_Language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', datasource?: 'tranquility' | 'singularity', language?: 'de' | 'en-us' | 'fr' | 'ja' | 'ru' | 'zh', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (names === null || names === undefined) {
            throw new Error('Required parameter names was null or undefined when calling postUniverseIds.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }
        if (language !== undefined && language !== null) {
            queryParameters = queryParameters.set('language', <any>language);
        }

        let headers = this.defaultHeaders;
        if (Accept_Language !== undefined && Accept_Language !== null) {
            headers = headers.set('Accept-Language', String(Accept_Language));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<PostUniverseIdsOk>(`${this.basePath}/universe/ids/`,
            names,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get names and categories for a set of ID&#39;s
     * Resolve a set of IDs to names and categories. Supported ID&#39;s for resolving are: Characters, Corporations, Alliances, Stations, Solar Systems, Constellations, Regions, Types  --- Alternate route: &#x60;/dev/universe/names/&#x60;  Alternate route: &#x60;/v2/universe/names/&#x60; 
     * @param ids The ids to resolve
     * @param datasource The server name you would like data from
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postUniverseNames(ids: Array<number>, datasource?: 'tranquility' | 'singularity', observe?: 'body', reportProgress?: boolean): Observable<Array<any>>;
    public postUniverseNames(ids: Array<number>, datasource?: 'tranquility' | 'singularity', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<any>>>;
    public postUniverseNames(ids: Array<number>, datasource?: 'tranquility' | 'singularity', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<any>>>;
    public postUniverseNames(ids: Array<number>, datasource?: 'tranquility' | 'singularity', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (ids === null || ids === undefined) {
            throw new Error('Required parameter ids was null or undefined when calling postUniverseNames.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (datasource !== undefined && datasource !== null) {
            queryParameters = queryParameters.set('datasource', <any>datasource);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<any>>(`${this.basePath}/universe/names/`,
            ids,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
